<!DOCTYPE html>
<!--
██████╗ ██╗ ██████╗████████╗██╗   ██╗██████╗ ███████╗
██╔══██╗██║██╔════╝╚══██╔══╝╚██╗ ██╔╝██╔══██╗██╔════╝
██████╔╝██║██║  ███╗  ██║    ╚████╔╝ ██████╔╝█████╗
██╔══██╗██║██║   ██║  ██║     ╚██╔╝  ██╔═══╝ ██╔══╝
██████╔╝██║╚██████╔╝  ██║      ██║   ██║     ███████╗
╚═════╝ ╚═╝ ╚═════╝   ╚═╝      ╚═╝   ╚═╝     ╚══════╝

Hello there. Welcome to bigty.pe where you can type things and
they appear quite big, and give you a link to send to a friend.
It's great for when you have something big to say.

Found a bug? Report it at https://github.com/leebyron/bigtype/issues
-->
<html>
  <head>
    <title>Big Type</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <meta name="HandheldFriendly" content="true" />
    <meta property="og:title" content="A BigType message" />
    <meta property="og:description" content="Someone had something big to say." />
    <meta name="twitter:card" content="summary" />
    <style>
      body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        -webkit-text-size-adjust: none;
      }

      #wrap {
        align-items: center;
        background-color: black;
        color: white;
        display: flex;
        height: 100%;
        justify-content: center;
        position: fixed;
        width: 100%;
      }

      #wrap.blink {
        background-color: white;
        color: black;
      }

      #text {
        font-family:
          -apple-system, BlinkMacSystemFont,
          "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell,
          "Fira Sans", "Droid Sans", "Helvetica Neue",
          sans-serif;
        line-height: 0.92;
        padding: 6vmax;
        text-align: center;
        -webkit-hyphens: auto;
        -moz-hyphens: auto;
        -ms-hyphens: auto;
        hyphens: auto;
      }

      #text:focus {
        outline: none;
      }
    </style>
  </head>
  <body>
    <div id="wrap">
      <div id="text" contentEditable>Big Type</div>
    </div>
    <script>
      (function(){
        console.log(
          '██████╗ ██╗ ██████╗████████╗██╗   ██╗██████╗ ███████╗\n' +
          '██╔══██╗██║██╔════╝╚══██╔══╝╚██╗ ██╔╝██╔══██╗██╔════╝\n' +
          '██████╔╝██║██║  ███╗  ██║    ╚████╔╝ ██████╔╝█████╗\n' +
          '██╔══██╗██║██║   ██║  ██║     ╚██╔╝  ██╔═══╝ ██╔══╝\n' +
          '██████╔╝██║╚██████╔╝  ██║      ██║   ██║     ███████╗\n' +
          '╚═════╝ ╚═╝ ╚═════╝   ╚═╝      ╚═╝   ╚═╝     ╚══════╝\n'
        );

        var MAXIMUM_LENGTH = 2000;
        var MINIMUM_SIZE = 10;

        var wrap = document.getElementById('wrap');
        var text = document.getElementById('text');
        var content = decodeURIComponent(window.location.pathname.slice(1).replace(/\+/g, ' ')).replace(/</g, '&gt;').slice(0, MAXIMUM_LENGTH);

        // Highlight all text if no initial content.
        if (content) {
          text.innerText = document.title = content;
        } else {
          var s = window.getSelection();
          s.removeAllRanges();
          var r = document.createRange();
          r.selectNodeContents(text.childNodes[0]);
          s.addRange(r);
        }

        // Optimize size.
        findPerfectSize();
        window.onresize = findPerfectSize;

        // Listen for text changes.
        var observer = new MutationObserver(updateText);
        observer.observe(text, { characterData: true, childList: true, subtree: true });

        function updateText() {
          var newContent = text.innerText.replace(/\u00A0/g, ' ').replace(/\n/g, '');

          // Remove any pasted or typed styles.
          if (text.childNodes.length > 1 || newContent.length > MAXIMUM_LENGTH) {
            var range = window.getSelection().getRangeAt(0);
            var start = getGlobalOffset(range.startContainer, range.startOffset);
            var end = getGlobalOffset(range.endContainer, range.endOffset);
            range.detach();
            newContent = newContent.slice(0, MAXIMUM_LENGTH);
            text.innerText = newContent;
            range = document.createRange();
            var textNode = text.childNodes[0];
            range.setStart(textNode, start);
            range.setEnd(textNode, end);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
          }

          // Update content if necessary.
          if (newContent !== content) {
            content = newContent;

            // Resize to fit.
            findPerfectSize();

            // Update Title & URL.
            document.title = content.replace(/</g, '&gt;');
            window.history.replaceState({}, null, encodeURIComponent(content.trim()) || '/');
          }
        }

        function getGlobalOffset(node, offset) {
          while (node !== text) {
            var parent = node.parentNode;
            var children = parent.childNodes;
            for (var i = 0; i < children.length && children[i] !== node; i++) {
              offset += children[i].textContent.length;
            }
            node = parent;
          }
          return offset;
        }

        function focusText() {
          text.focus();
        }

        var SHAKE_FORCE = 13; // ~1.5G
        window.addEventListener('devicemotion', ev => {
          var f = ev.acceleration || ev.accelerationIncludingGravity;
          if (f.x * f.x + f.y * f.y + f.z * f.z > SHAKE_FORCE * SHAKE_FORCE) {
            makeBlink();
          }
        });

        var isBlinking;
        function makeBlink() {
          if (isBlinking) {
            wrap.className = '';
            isBlinking = clearInterval(isBlinking);
          } else {
            isBlinking = setInterval(function () {
              wrap.className = wrap.className ? '' : 'blink';
            }, 180);
          }
        }

        function findPerfectSize() {
          if (!text.innerText) {
            return;
          }

          // Determine target size.
          var maxW = wrap.offsetWidth;
          var maxH = wrap.offsetHeight;

          // Predicate for bisection search.
          function isTooBig(size) {
            text.style.fontSize = size + 'px';
            return text.offsetWidth > maxW || text.offsetHeight > maxH;
          }

          // Determine initial bounds.
          var high, low;
          high = low = parseInt(window.getComputedStyle(text).fontSize, 10) || 100;
          if (isTooBig(high)) {
            do {
              high = low;
              low = Math.max(MINIMUM_SIZE, Math.floor(high / 2));
            } while (low > MINIMUM_SIZE && isTooBig(low));
          } else {
            do {
              low = high;
              high = low * 2;
            } while (!isTooBig(high));
          }

          // Bisect to find largest size that isn't too big (or timeout).
          var runs = 0;
          while (high - low > 1 && runs < 20) {
            var mid = Math.floor((high + low) / 2);
            if (isTooBig(mid)) {
              high = mid;
            } else {
              low = mid;
            }
            runs++;
          }

          // Update text font size.
          text.style.fontSize = low + 'px';
        }
      })();
    </script>
    <script>
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      ga('create', 'UA-61714711-2', 'auto');
      ga('send', 'pageview');
    </script>
  </body>
</html>
